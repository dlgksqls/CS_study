<h1>동기화와 교착 상태</h1>

<h2 style="color: cornflowerblue"> 임계 구역</h2>

<h3> 공유 자원</h3>
<p>프로세스 혹은 스레드가 공유하는 자원</p>

<h3> 임계 구역</h3>
<p>공유 자원에 접근하는 코드 중 동시에 실행했을 때 문제가 발생할 수 있는 코드</p>
<p>동시에 실행되는 프로세스나 스레드가 동시에 임계 구역에 진입하여 실행되면 문제가 발생할 수 있음</p>

<h3> 레이스 컨디션</h3>
<p>프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황</p>
<p>레이스 컨이션이 발생하면 자원의 일관성이 손상될 수 있기 때문에 2개 이상의 프로세스 혹은 스레드가 임계 영역에 진입하고자 한다면 둘 중 하나는 작업이 끝날 때 까지 대기해야함</p>

<h2 style="color: cornflowerblue"> 동기화</h2>
<h3>동기화란 다음 2가지 조건을 준수하며 실행하는 것</h3>
<ul>
    <li>실행 순서 제어 : 프로세스 및 스레드를 올바른 순서로 실행하기</li>
    <li>상호 배제 : 동시에 접근해서는 안되는 자원에 하나의 프로세스 및 스레드만 접근하기</li>
</ul>

<h3> 뮤텍스 락 (Mutex Lock)</h3>
<p>동시에 접근해서는 안되는 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구</p>
<strong>임계 구역에 접근하고자 한다면 반드시 락(lock)을 획득(acquire)해야 하고,</strong><br>
<strong>임계 구역에서의 작업이 끝났으면 락을 해제(release) 해야한다.</strong>

![뮤택스 락.png](image%2F%EB%AE%A4%ED%83%9D%EC%8A%A4%20%EB%9D%BD.png)

<h3> 세마포</h3>
<p>뮤텍스 락은 하나의 공유 자원을 고려하는 동기화 도구</p>
<p>하지만 공유 자원은 늘 하나만 있는 것이 아님</p>
<p>한번에 3개, 4개의 프로세스 및 스레드까지 특정 자원을 이용할 수 있는 상황도 존재함</p>
<ul>
    <li><strong>번수 S 사용</strong> : 사용 가능한 공유 자원의 개수를 나타내는 변수</li>
    <li><strong>wait( ) 함수</strong> : 임계 구역 진입 전 호출하는 함수</li>
    <li><strong>signal( ) 함수</strong> : 임계 구역 진입 후 호출하는 함수</li>
</ul>

![세마포.png](image%2F%EC%84%B8%EB%A7%88%ED%8F%AC.png)
![wait 함수.png](image%2Fwait%20%ED%95%A8%EC%88%98.png)
![signal 함수.png](image%2Fsignal%20%ED%95%A8%EC%88%98.png)
![세마포 실행 과정.png](image%2F%EC%84%B8%EB%A7%88%ED%8F%AC%20%EC%8B%A4%ED%96%89%20%EA%B3%BC%EC%A0%95.png)

<h3> 조건 변수와 모니터</h3>
<h4>조건 변수</h4>
<p>실행 순서 제어를 위한 동기화 도구</p>
<p>특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 스레드의 실행 순서를 제어할 수 있음</p>
<ul>
    <li>wait() : 호출한 프로세스 및 스레드의 상태를 대기 상태로 전환하는 함수</li>
    <li>signal() : wait()로 일시 중지된 프로세스 및 스레드의 실행을 재개하는 함수</li>
</ul>

![조건 변수.png](image%2F%EC%A1%B0%EA%B1%B4%20%EB%B3%80%EC%88%98.png)

<h4> 모니터</h4>
<p>공유 자원과 그 공유 자원을 다루는 함수(인터페이스)로 구성된 동기화 도구</p>
<p>상호 배제를 위한 동기화뿐만 아니라 실행 순서 제어를 위한 동기화까지 가능함</p>

![모니터.png](image%2F%EB%AA%A8%EB%8B%88%ED%84%B0.png)

<h3> 스레드 안전</h3>
<p>멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태</p>
<p>레이스 컨디션이 발생했다면 이는 스레드 안전하지 않은 상황임</p>
<p>Java에 Vector의 add()는 스레드 안정성 보장돼어있음, synchronize()로 구현되어있기 때문</p>
<p>하지만 Java에 ArrayList의 add()는 스레드 안정승이 보장되지 않음</p>
<p>코드 내부에 synchronized()메서드가 없기 때문</p>
<p>따라서 add()를 여러 스레드로 동시 실행하면 레이스 컨디션이 발생할 수 있음</p>

<h2 style="color: cornflowerblue"> 교착 상태</h2>
<p>프로세스를 실행하기 위해서는 자원이 필요함. 하지만 2개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다린다면 더 이상 어떤 프로세스도 진행할 수 없는 교착 상태가 발생할 수 있음</p>
<p>교착 상태란 <strong>일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상을 말함</strong></p>

![교착 상태.png](image%2F%EA%B5%90%EC%B0%A9%20%EC%83%81%ED%83%9C.png)

<h3> 교착 상태의 발생 조건</h3>
<ul>
    <li><strong>상호 배제</strong> : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상황에서 교착 상태 발생</li>
    <li><strong>점유와 대기</strong> : 한 프로세스가 어떤 자원을 할당받은 상태(점유)에서 다른 자원 할당받기를 기다린다면(대기) 교착 상태가 발생할 수 있음</li>
    <li><strong>비선점</strong> : 자원이 비선점되었다는 말은 해당 자원을 이용하는 프로세스의 작업이 끝나아먄 비로소 자원을 이용할 수 있다는 것을 의미, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 경우</li>
    <li><strong>원형 대기</strong> : 프로세스와 프로세스가 요청한 자원이 원의 형태를 이루는 경우</li>
</ul>

<h3> 교착 상태의 해결 방법</h3>
<ul>
    <li><strong>예방</strong> : 교착 상태를 발생시키는 4가지 필요 조건 중 하나를 충족하지 못하게 하는 방법</li>
    <li><strong>회피</strong> : 교착 상태가 발생하지 않을 정도로만 조심하여 자원을 할당하는 방법, 교착 상태 회피는 기본적으로 교착 상태를 한정된 자원의 무분별한 할당을 으로 인해 발생하는 문제로 간주함 ex) 은행원 알고리즘 (Banker's Algorithm)</li>
    <li><strong>검출 후 회복</strong> : 교착 상태의 발생을 인정하고 처리하는 사후 조치에 해당됨, 운영체제는 프로세스가 자원을 요구할 때마다 그때 그떄 자원을 할당하고 주기적으로 교착 상태의 발생 여부를 검사함, 교착 상태가 검출되면 프로세스를 자원 선점을 통해 회복시키거나, 교착 상태에 놓인 프로세스를 강제 종료함으로써 회복 시킬 수 있음</li>
</ul>