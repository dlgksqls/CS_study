<h1>프로세스와 스레드</h1>

<p>포그라운드 프로세스 : 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스</p>
<p>백그라운드 프로세스 : 사용자가 보지 못하는 곳에서 실행되는 프로세스</p>
<ul>
    <li>데몬 : 사용자와 별다른 상호작요 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스</li>
    <li>서비스 : 윈도우 운영체제에서는 데몬을 서비스라고 함</li>
</ul>

<p>커널 영역에서는 프로세스 제어 블록(PCB)이라는 정보가 저장됨</p>
<p>사용자 영역에는 실행중인 프로세스가 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장됨</p>

<p>코드 영역(=텍스트 영역) : 실행 가능한 명령어가 저장되는 공간, CPU가 읽고 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있는 읽기 전용 공간임</p>
<p>데이터 영역 : 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간, 정적 변수나 전역 변수가 대표적으로 저장됨</p>
<p>힙 영역 : 프로그램을 만드는 사용자(개발자)가 직접 할당 가능한 저장 공간, 힙 영역에 메모리 공간을 할당하고 반환하지 않으면 메모리 누수 문제를 초래할 수 있음</p>
<p>스택 영역 : 데이터 영역에 담기는 값과 달리 일시적으로 사용할 값들이 저장되는 공간, 함수의 실행이 끝나면 사라지는 매개변수, 지역 변수, 함수 복귀 주소 등이 대표적으로 저장됨</p>

<h2 style="color: cornflowerblue"> PCB와 문맥 교환</h2>
<h3>프로세스 제어 블록 (PCB : Process Control Block)</h3>
<p>운영체제가 메모리에 적재된 다수의 프로세스를 관리하려면 프로세스를 식별할 수 잇는 커널 영역 내의 정보가 필요함</p>
<p>프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종</p>
<p>새로운 프로세스가 메모리에 적재(프로세스 생성)됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기됨</p>
<p>커널 내의 프로세스 테이블의 혀앹로 관리됨</p>
<p>PCB담기는 정보</p>
<ul>
    <li><strong>프로세스 ID</strong></li>
    <li>프로세스 실행 과정에서 사용한 <strong>레지스터 값</strong></li>
    <li>프로세스가 현재 어떤 상태인지 나타내느 <strong>프로세스 상태</strong></li>
    <li><strong>CPU 스케줄링 정보</strong></li>
    <li>프로세스의 메모리상 적재 위치를 알 수 있는 <strong>메모리 관련 정보</strong></li>
    <li>프로세스가 사용한 <strong>파일 및 입출력장치 관련 정보</strong></li>
</ul>

![PCB.jpeg](image%2FPCB.png)

<h3> 문맥 교환 (Context Switch)</h3>
<p>백업 대상이 되는 중간 정보, 즉 프로세스의 수행을 재개하기 위해 기억해야 할 정보를 <strong>문맥(Context)이라고 함</strong></p>
<p>기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것</p>
<p>프로세스 간의 잦은 문맥 교환이 발생하면 캐시 미스가 발생할 가능성이 높아져 메모리로부터 실행할 프로세스의 내용을 가져오는 작업이 빈번해져서 큰 오버헤드로 이어질 수 있음</p>

![문맥교환.png](image%2F%EB%AC%B8%EB%A7%A5%EA%B5%90%ED%99%98.png)

<h2 style="color: cornflowerblue"> 프로세스의 상태</h2>
<h3>프로세스의 대표적인 상태 : 생성, 준비, 실행, 대기, 종료</h3>

![프로세스 상태.png](image%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%83%81%ED%83%9C.png)

<h4 style="color: cornflowerblue"> 생성 상태(new)</h4>
<p>프로세스를 생성 중인 상태, 메모리에 적재되어 PCB를 할당받은 상태</p>

<h4 style="color: cornflowerblue"> 준비 상태(ready)</h4>
<p>CPU를 할당받아 실행할 준비가 됐지만 자신의 차례를 기다리고있는 상태, CPU를 할당받으면 실행 상태가 됨</p>

<h4 style="color: cornflowerblue"> 실행 상태(running)</h4>
<p>CPU를 할당받아 실행 중인 상태, 일정 시간 동안만 CPU를 사용할 수 있음</p>

<h4 style="color: cornflowerblue"> 대기 상태(blocked)</h4>
<p>프로세스가 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 등 곧장 실행이 불가능한 조건에 놓이는 경우</p>

<h4 style="color: cornflowerblue"> 종료 상태(terminated)</h4>
<p>프로세스가 종료된 상태</p>

<h2 style="color: cornflowerblue"> 멀티프로세스와 멀티스레드</h2>

<h3> 멀티 프로세스</h3>
<p>동시에 여러 프로세스가 실행되는 것</p>
<p>프로세스별로 파일과 입출력장치 등의 자원이 독립적으로 할당됨</p>
<p>한 프로세스의 실행 과정에서 문제가 발생하더라도 다른 프로세스에 직접적인 영향을 끼치지 않는 경우가 많음</p>

<h3> 멀티 스레드</h3>
<p>스레드는 스레드ID, 프로그램 카운터, 레지스터 값, 스택 등으로 구성</p>
<p>스레드마다 각각의 프로그램 카운터 값과 스택을 가지고 있기 때문에 스레드마다 다음에 실행할 주소를 가질 수 있고, 연산 과정의 임시 저장 값을 가질 수 있음</p>

<h3> 멀티 프로세스와 멀티 스레드의 차이</h3>
<p>멀티프로세스와 멀티스레드의 가장 큰 차이점은 <strong>자원의 공유 여부</strong>임</p>
<p>서로 다른 프로세스들은 기본적으로 자원을 공유하지 않음 (=독립적으로 실행)</p>
<p>같은 프로세스를 실행하는 여러 스레드들은 프로세스의 자원을 공유함</p>
<p>스레드들은 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하고, 열린 파일과 같은 프로세스의 자원을 공유하기 때문에 쉽게 협력할 수 있음</p>
<p>멀티 스레드 환경에서는 한 스레드에 생긴 문제가 프로세스 전체의 문제가 될 수 있음</p>

![멀티 프로세스, 멀티 스레드.png](image%2F%EB%A9%80%ED%8B%B0%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%2C%20%EB%A9%80%ED%8B%B0%20%EC%8A%A4%EB%A0%88%EB%93%9C.png)

<h2 style="color: cornflowerblue"> 프로세스 간 통신 (IPC)</h2>
<p>공유 메모리 : 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식, 이 방법의 핵심은 각 프로세스가 <strong>마지 자신의 메모리 영역을 읽고 쓰는 것처럼</strong>통신한다는 점임, 데이터를 주고받는 과정에서 커널의 개입이 거의 없음</p>
<p>각 프로세스가 각자의 메모리 영역을 읽고 쓰는 것뿐이므로 메시지 전달 방식보다 통신 속도가 빠름</p>
<p>공유 메모리 영역을 동시에 읽고 쓸 경우, 데이터의 일관성이 훼손될 수 있음 (=레이스 컨디션)</p>
<p>메시지 전달 : 프로세스 간에 주고받을 데이터를 메시지의 형태로 주고받는 방식</p>
<p>프로세스 간에 주고받을 데이터가 커널을 거쳐 송수신되는 통신 방식</p>
<p>메시지를 보내는 수단과 받는 수단이 명확하게 구분되어 있음. ex) 메시지를 보내는 시스템 콜 send(), 메시지를 받는 시스템 콜 recv()</p>
<p>공유 메모리 기반보다 커널의 도움을 적극적으로 받을 수 있으므로 레이스 컨디션, 동기화 등의 문제를 고려하는 일이 상대적으로 적음</p>
<p>데이터가 커널을 통해 왔다갔다하므로 속도가 느림</p>
<p>대표적인 수단으로 파이프, 시그널, 소켓, 원격 프로시저 호출(RPC)등이 있음</p>
<ul>
    <li>파이프 : 단방향 프로세스 간의 통신 도구, 주로 읽기용 파이프와 쓰기용 파이프 2개를 이용해 양방향으로 통신함</li>
    <li>시그널 : 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적인 신호</li>
</ul>