<h1>CPU 스케줄링</h1>

<h3> 우선순위</h3>
<p>모든 프로세스는 CPU의 자원을 필요로 하기 때문에 운영체제는 공정하고 합리적인 방법으로 CPU의 자원을 프로세스에 할당해야 함</p>
<p>CPU의 자원을 할당받을 프로세스의 우선순위가 다르기 때문에 단순히 돌아가면서 CPU를 프로세스들에 할당하는 것이 아님</p>
<p>운영체제는 프로세스별 <strong>우선순위</strong>를 판단하여 PCB에 명시하고, 우선순위가 높은 프로세스에는 CPU의 자원을 더 빨리, 더 많이 할당함</p>
<p>운영체제는 가급적 CPU 활용률을 높게 유지할 수 있도록 우선순위를 할당함</p>

<h3> 스케줄링 큐</h3>
<p>운영체제는 프로세스들에게 '자원을 이용하고 싶다면 줄을 서서 기다릴 것'을 요구함</p>
<p>이 줄은 <strong>스케줄링 큐</strong>를 통해 구현됨</p>
<p>CPU를 이용하고 싶은 프로세스의 PCB와 메모리로 적재되고 싶은 프로세스의 PCB, 특정 입출력장치를 이용하고 싶은 프로세스의 PCB를 큐에 삽입하여 줄 세우는 것임</p>

![스케줄링 큐.png](image%2F%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%ED%81%90.png)

<ul>
    <li>준비 큐 (Ready Queue) : CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄</li>
    <li>대기 큐 (Waiting Queue) : 대기 상태에 접어든 프로세스의 PCB가 서는 줄</li>
</ul>

![준비 큐, 대기 큐.png](image%2F%EC%A4%80%EB%B9%84%20%ED%81%90%2C%20%EB%8C%80%EA%B8%B0%20%ED%81%90.png)

<h3> 선점형 스케줄링과 비선점형 스케줄링</h3>
<p>프로그램이 종류되지 않았음에도 실행 도중 스케줄링이 수행되는 경우</p>
<ul>
    <li>실행 상태에서 입출력 작업을 위해 대기 상태로 전환될 때 : 선점형 스케줄링, 비선점형 스케줄링</li>
    <li>실행 상태에서 타이머 인터럽트가 발생해 준비 상태로 변경될 때 : 선점형 스케줄링</li>
</ul>
<h4>선점형 스케줄링</h4>
<p>운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링</p>
<p>타이머 인터럽트 기반 스키줄링은 모두 선점형 스케줄링의 일종</p>
<p>프로세스마다 정해진 시간만큼만 CPU를 이용하고, 정해진 시간을 모두 소비하면 운영체제가 해당 프로세스로부터 CPU자원을 빼앗아 다음 프로세스에게 할당하는 방식</p>
<p>한 프로세스의 CPU 독점을 막고 여러 프로세스에 골고루 CPU 자원을 배분할 수 있다는 장점</p>
<p>문맥 교환 과정에서 오버헤드 발생 가능</p>

<h4> 비선점형 스케줄링</h4>
<p>CPU를 사용하고 있을 때 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식</p>
<p>비선점형 스케줄링으로 실행되는 프로세스가 있따면 다른 프로세스들은 그 프로세스의 CPU사용이 모두 끝날 때까지 기다려야함</p>
<p>선점형 스케줄링보다 문맥 교환의 횟수가 적기 때문에, 상대적으로 오버헤드의 발생이 적다는 장점</p>
<p>어떤 프로세스가 CPU를 사용 중이라면 당장 CPU를 사용해야 하는 프로세스라도 무작정 기다리는 수 밖에 없다는 단점</p>

<h2 style="color: cornflowerblue"> CPU 스케줄링 알고리즘</h2>
<h3> 1. 선입 선처리 스케줄링 FCFS(First Come First Service)</h3>
<p>준비 큐에 삽입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식</p>
<p>먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지언되는 문제 발생 가능 = 호위 효과</p>

<h3> 2. 최단 작업 우선 스케줄링 SJF(Shortest Job First)</h3>
<p>준비 큐에 삽임된 프로세스 중 CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 먼저 실행하는 스케줄링 방식</p>

<h3> 3. 라운드 로빈 스케줄링 R-R(Round-Robin)</h3>
<p>선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식</p>
<p><strong>타임 슬라이스</strong> : 프로세스가 CPU를 사용하도록 정해진 시간을 의미함</p>

<h3> 4. 최소 잔여 시간 우선 스케줄링 SRT(Shortest Remaining Time)</h3>
<p>최단 작업 우선 스케줄링과 라운드 로빈 스켄줄링을 합친 방식</p>
<p>정해진 타임 슬라이스만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택함</p>

<h3> 5. 우선순위 스케줄링 Priority</h3>
<p>프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식</p>
<p>우선순위가 높은 프로세스를 먼저 처리하는 방식이기 때문에 우선순위가 낮은 프로세스는 계속해서 실행이 연기될 수 있음 = 아사, 고아 현상 (Starvation)</p>
<p>아사, 고아 현상을 방지하기 위해 <strong>에이징 기법</strong>을 사용함</p>
<p>에이징 기법 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식</p>

<h3> 6. 다단계 큐 스케줄링 Multilevel Queue</h3>
<p>우선순위 스케줄링의 발전된 형태, 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식</p>
<p>우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있게 되면, 그 다음으로 우선순위가 높은 큐에 있는 프로세스를 처리함</p>

<h3> 7. 다단계 피드백 큐 스케줄링 Multilevel Feedback Queue</h3>
<p>다단계 큐 스케줄링과 비슷하게 동작하지만, <strong>큐 사이를 이동할 수 있다는 점</strong>에서 차이가 있음</p>
<p>해당 큐에서 프로세스의 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행됨</p>
<p>또 다음 큐에서 실행이 끝나지 않는 프로세스는 그 다음 우선순위 큐에 삽입되어 실행됨</p>
<p>결국 오래 CPU를 사용해야 하는 프로세스의 우선순위가 점차 낮아지게 됨</p>